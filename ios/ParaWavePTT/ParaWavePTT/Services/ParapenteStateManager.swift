import Auth0
import AuthenticationServices
import Foundation
import JWTDecode
import SwiftUI

/*
 Copyright (C) 2025 Ronan Le Meillat
 SPDX-License-Identifier: AGPL-3.0-or-later

 This file is part of ParaWave PTT.
 ParaWave PTT is free software: you can redistribute it and/or modify
 it under the terms of the GNU Affero General Public License as published by
 the Free Software Foundation, either version 3 of     // Stop any active transmission
    if let pttChannelManager = pttChannelManager {
      pttChannelManager.requestStopTransmission()
    }

    // Leave the channel if connected
    if let pttChannelManager = pttChannelManager {
      try? await pttChannelManager.leaveCurrentChannel()
    }

    // Clean up references
    pttChannelManager = nilor
 (at your option) any later version.

 ParaWave PTT is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Affero General Public License for more details.

 You should have received a copy of the GNU Affero General Public License
 along with this program. If not, see <https://www.gnu.org/licenses/agpl-3.0.en.html>.
*/

// Main application state manager for ParaWave PTT
@MainActor
class ParapenteStateManager: ObservableObject {

  // MARK: - Published Properties

  @Published var currentState: ParapenteAppState = .launching
  @Published var showError = false
  @Published var errorMessage = ""

  // MARK: - Dependencies

  private var networkService: ParapenteNetworkService?
  private var pttChannelManager: PTTChannelManager?
  private let keychainManager = Auth0KeychainManager()

  // MARK: - Initialization

  init() {
    setupNotificationObservers()
  }

  private func setupNotificationObservers() {
    NotificationCenter.default.addObserver(
      self,
      selector: #selector(handleAuthenticationStateChanged),
      name: .auth0AuthenticationStateChanged,
      object: nil
    )

    NotificationCenter.default.addObserver(
      self,
      selector: #selector(handleTokenWillExpire),
      name: .auth0TokenWillExpire,
      object: nil
    )
  }

  // MARK: - Public Methods

  /// Initialize the app with required services
  func initialize(networkService: ParapenteNetworkService) async {
    self.networkService = networkService

    // Check authentication state at startup
    await checkAuthenticationState()
  }

  /// Check authentication state and transition to the appropriate app state
  private func checkAuthenticationState() async {
    let authStatus = keychainManager.getAuthenticationStatus()

    switch authStatus {
    case .authenticated(_, let userId, let permissions):
      print("User already authenticated: \(userId)")
      transition(to: .authenticated(permissions: permissions))
      await loadAvailableChannels()

    case .unauthenticated:
      print("Authentication required")
      transition(to: .authentication)

    case .error(let error):
      print("Authentication error: \(error)")
      transition(to: .authentication)
    }
  }

  // MARK: - Authentication Methods

  /// Start the Auth0 authentication process
  func authenticateWithAuth0() async {
    transition(to: .authentication)

    do {
      // Load Auth0 configuration from environment
      EnvironmentReader.loadEnvironment()

      let domain = EnvironmentReader.get("AUTH0_DOMAIN") ?? "highcanfly.eu.auth0.com"
      let clientId = EnvironmentReader.get("AUTH0_CLIENT_ID") ?? "YOUR_AUTH0_CLIENT_ID"
      let audience =
        EnvironmentReader.get("AUTH0_AUDIENCE") ?? "https://ptt-backend.highcanfly.club"

      #if DEBUG
        print("üîê Starting Auth0 authentication...")
        print("   Domain: \(domain)")
        print("   Client ID: \(clientId)")
        print("   Audience: \(audience)")
      #endif

      // Use Auth0 SDK for real authentication
      let credentials =
        try await Auth0
        .webAuth(clientId: clientId, domain: domain)
        .audience(audience)
        .scope("openid profile email read:api")
        .start()

      #if DEBUG
        print("‚úÖ Auth0 authentication successful")
        print("   Access Token: \(credentials.accessToken.prefix(20))...")
        print("   Expires At: \(credentials.expiresIn)")
      #endif

      // Decode the JWT token to get user info and permissions
      let decodedToken = try decode(jwt: credentials.accessToken)
      let userId = decodedToken.subject ?? "unknown_user"
      let permissions = decodedToken.claim(name: "permissions").array ?? ["read:api"]

      #if DEBUG
        print("   User ID: \(userId)")
        print("   Permissions: \(permissions)")
      #endif

      // Store authentication information in keychain
      let expiresInSeconds = credentials.expiresIn.timeIntervalSinceNow

      let tokenInfo = Auth0KeychainManager.Auth0TokenInfo(
        accessToken: credentials.accessToken,
        refreshToken: credentials.refreshToken,
        expiresIn: expiresInSeconds,
        userId: userId,
        permissions: permissions
      )

      try keychainManager.updateTokenInfo(tokenInfo)

      print("‚úÖ Authentication succeeded for user: \(userId)")
      transition(to: .authenticated(permissions: permissions))

      // Load available channels
      await loadAvailableChannels()

    } catch {
      print("‚ùå Authentication error: \(error)")

      // Handle specific Auth0 errors
      if let webAuthError = error as? WebAuthError {
        switch webAuthError {
        case .userCancelled:
          print("   User cancelled authentication")
          // Don't show error, just return to authentication state
          transition(to: .authentication)
          return
        case .noAuthorizationCode:
          print("   No authorization code received")
        case .invalidInvitationURL:
          print("   Invalid invitation URL")
        case .unknown:
          print("   Unknown Auth0 error")
        case .noBundleIdentifier:
          print("   No bundle identifier found")
        case .pkceNotAllowed:
          print("   PKCE not allowed")
        case .idTokenValidationFailed:
          print("   ID token validation failed")
        default:
          print("   Other Auth0 error")
        }
      }

      transition(to: .error(.authenticationFailed(error)))
    }
  }

  /// Log out and clean up data
  func logout() async {
    do {
      // Load Auth0 configuration for logout
      EnvironmentReader.loadEnvironment()
      let domain = EnvironmentReader.get("AUTH0_DOMAIN") ?? "highcanfly.eu.auth0.com"
      let clientId = EnvironmentReader.get("AUTH0_CLIENT_ID") ?? "YOUR_AUTH0_CLIENT_ID"

      #if DEBUG
        print("üö™ Starting Auth0 logout...")
      #endif

      // Clear the Auth0 session (optional - clears browser cookies)
      _ =
        try? await Auth0
        .webAuth(clientId: clientId, domain: domain)
        .clearSession()

      // Clear local keychain
      try keychainManager.deleteAllTokens()

      // Stop all services
      await cleanupServices()

      #if DEBUG
        print("‚úÖ Logout successful - Auth0 session and local tokens cleared")
      #endif

      transition(to: .authentication)

    } catch {
      print("‚ùå Error during logout: \(error)")

      // Even if Auth0 logout fails, still clear local data
      try? keychainManager.deleteAllTokens()
      await cleanupServices()

      showErrorMessage("Error during logout: \(error.localizedDescription)")
      transition(to: .authentication)
    }
  }

  // MARK: - Channel Management

  /// Load available channels for the user
  private func loadAvailableChannels() async {
    guard let networkService = networkService else {
      transition(
        to: .error(.networkError(NSError(domain: "NoNetworkService", code: 0, userInfo: nil))))
      return
    }

    do {
      print("Loading available channels...")
      let channels = try await networkService.getChannels()
      print("Loaded \(channels.count) available channels")

      // Move to channel selection if channels are available
      if !channels.isEmpty {
        transition(to: .channelSelection)
      }

    } catch {
      print("Error loading channels: \(error)")
      transition(to: .error(.networkError(error)))
    }
  }

  /// Join a PTT channel
  func joinChannel(_ channel: PTTChannel) async {
    guard let networkService = networkService else {
      showErrorMessage("Network service not available")
      return
    }

    do {
      // Create the PTT manager if it doesn't exist
      if pttChannelManager == nil {
        pttChannelManager = PTTChannelManager(networkService: networkService)
      }

      // Join the channel
      try await pttChannelManager?.joinChannel(channel)

      print("Channel joined successfully: \(channel.name)")
      transition(to: .channelJoined(channel: channel))

    } catch {
      print("Error joining channel: \(error)")
      showErrorMessage("Unable to join channel: \(error.localizedDescription)")
    }
  }

  /// Leave the current channel
  func leaveCurrentChannel() async {
    do {
      try await pttChannelManager?.leaveCurrentChannel()
      print("Channel left successfully")

      // Return to channel selection
      await loadAvailableChannels()

    } catch {
      print("Error leaving channel: \(error)")
      showErrorMessage("Error leaving channel: \(error.localizedDescription)")
    }
  }

  // MARK: - PTT Transmission

  /// Start a PTT transmission
  func startTransmission() async {
    print("üéôÔ∏è Starting PTT transmission...")
    
    guard let pttChannelManager = pttChannelManager else {
      print("‚ùå PTT channel manager not available")
      showErrorMessage("PTT channel manager not available")
      return
    }

    do {
      // Check microphone permissions
      print("üé§ Checking microphone permissions...")
      guard await PTTChannelManager.requestMicrophonePermission() else {
        print("‚ùå Microphone permission denied")
        showErrorMessage("Microphone permission required for PTT transmissions")
        return
      }
      print("‚úÖ Microphone permission granted")

      // Start transmission
      print("üî¥ Starting PTT transmission...")
      try await pttChannelManager.requestStartTransmission()

      print("‚úÖ PTT transmission started successfully")

      if case .channelJoined(_) = currentState {
        transition(to: .activeTransmission(sessionId: "active_transmission"))
      }

    } catch {
      print("‚ùå Error starting transmission: \(error)")
      print("   Error type: \(type(of: error))")
      
      // Provide more specific error messages based on the error
      if error.localizedDescription.contains("channel") {
        showErrorMessage("No active PTT channel - please ensure you've joined a channel properly")
      } else if error.localizedDescription.contains("framework") || error.localizedDescription.contains("initialize") {
        showErrorMessage("Apple's PushToTalk framework not initialized - try restarting the app")
      } else {
        showErrorMessage("Unable to start transmission: \(error.localizedDescription)")
      }
    }
  }

  /// Stop the PTT transmission
  func stopTransmission() async {
    guard let pttChannelManager = pttChannelManager else {
      return
    }

    pttChannelManager.requestStopTransmission()
    print("PTT transmission stopped")

    // Return to joined channel state
    if let currentChannel = await getCurrentChannel(from: pttChannelManager) {
      transition(to: .channelJoined(channel: currentChannel))
    }
  }

  // MARK: - Emergency Functions

  /// Join the emergency channel
  func joinEmergencyChannel() async {
    guard let networkService = networkService else {
      showErrorMessage("Network service not available")
      return
    }

    do {
      // Search for an emergency channel
      let channels = try await networkService.getChannels(type: .emergency)

      if let emergencyChannel = channels.first {
        await joinChannel(emergencyChannel)
      } else {
        showErrorMessage("No emergency channel available")
      }

    } catch {
      print("Error searching for emergency channel: \(error)")
      showErrorMessage("Unable to access emergency channel: \(error.localizedDescription)")
    }
  }

  // MARK: - State Management

  /// Transition to a new state
  private func transition(to newState: ParapenteAppState) {
    print("State: \(currentState) -> \(newState)")
    currentState = newState
  }

  /// Display an error message
  private func showErrorMessage(_ message: String) {
    errorMessage = message
    showError = true
  }

  /// Clear the error message
  func clearError() {
    showError = false
    errorMessage = ""
  }

  // MARK: - Cleanup

  private func cleanupServices() async {
    // Stop the transmission if active
    if let pttChannelManager = pttChannelManager {
      pttChannelManager.requestStopTransmission()
    }

    // Leave the channel if connected
    if let pttChannelManager = pttChannelManager {
      try? await pttChannelManager.leaveCurrentChannel()
    }

    // Clean up references
    pttChannelManager = nil
  }

  // MARK: - Notification Handlers

  @objc private func handleAuthenticationStateChanged() {
    Task {
      await checkAuthenticationState()
    }
  }

  @objc private func handleTokenWillExpire() {
    Task {
      await refreshAuthenticationToken()
    }
  }

  private func refreshAuthenticationToken() async {
    do {
      // Load Auth0 configuration
      EnvironmentReader.loadEnvironment()
      let domain = EnvironmentReader.get("AUTH0_DOMAIN") ?? "highcanfly.eu.auth0.com"
      let clientId = EnvironmentReader.get("AUTH0_CLIENT_ID") ?? "YOUR_AUTH0_CLIENT_ID"

      // Get the refresh token from keychain
      guard let refreshToken = try keychainManager.getRefreshToken() else {
        print("üîÑ No refresh token available, redirecting to login")
        transition(to: .authentication)
        return
      }

      #if DEBUG
        print("üîÑ Refreshing Auth0 token...")
      #endif

      // Use Auth0 SDK to refresh the token
      let credentials =
        try await Auth0
        .authentication(clientId: clientId, domain: domain)
        .renew(withRefreshToken: refreshToken)
        .start()

      // Decode the new JWT token
      let decodedToken = try decode(jwt: credentials.accessToken)
      let userId = decodedToken.subject ?? "unknown_user"
      let permissions = decodedToken.claim(name: "permissions").array ?? ["read:api"]

      // Update the stored token information
      let expiresInSeconds = credentials.expiresIn.timeIntervalSinceNow

      let tokenInfo = Auth0KeychainManager.Auth0TokenInfo(
        accessToken: credentials.accessToken,
        refreshToken: credentials.refreshToken ?? refreshToken,  // Keep existing refresh token if none provided
        expiresIn: expiresInSeconds,
        userId: userId,
        permissions: permissions
      )

      try keychainManager.updateTokenInfo(tokenInfo)

      #if DEBUG
        print("‚úÖ Token refreshed successfully for user: \(userId)")
      #endif

      // Continue with current state - no need to redirect to authentication

    } catch {
      print("‚ùå Token refresh failed: \(error)")

      // If refresh fails, clear tokens and redirect to authentication
      try? keychainManager.clearExpiredTokens()
      transition(to: .authentication)
    }
  }

  // MARK: - Helper Methods

  private func getCurrentChannel(from pttManager: PTTChannelManager) async -> PTTChannel? {
    // Retrieve the current channel from the PTT manager
    return pttManager.currentChannel
  }
}

// MARK: - State Extensions

extension ParapenteStateManager {

  /// Retrieve the current PTT state
  func getCurrentPTTState() -> String? {
    guard let pttManager = pttChannelManager else { return nil }

    if pttManager.isTransmitting {
      return "transmitting"
    } else if pttManager.isJoined {
      return "connected"
    } else {
      return "disconnected"
    }
  }

  /// Check if a transmission can be started
  func canStartTransmission() -> Bool {
    return pttChannelManager != nil
  }

  /// Retrieve the current audio stats (deprecated - audio handled by Apple framework)
  func getCurrentAudioStats() -> AudioStats? {
    return nil // Audio stats are now handled internally by Apple's PTT framework
  }

  /// Check if the user has a specific permission
  func hasPermission(_ permission: String) -> Bool {
    return keychainManager.hasPermission(permission)
  }

  /// Retrieve the current network info
  func getNetworkInfo() -> NetworkInfo? {
    return networkService?.getNetworkInfo()
  }
}

// MARK: - Development Extensions

#if DEBUG
  extension ParapenteStateManager {

    /// Debug methods for development
    func debugPrintCurrentState() {
      print("=== State Manager Debug Info ===")
      print("Current State: \(currentState)")
      print("Network Service: \(networkService != nil ? "Available" : "Nil")")
      print("PTT Manager: \(pttChannelManager != nil ? "Available" : "Nil")")
      print("Authentication Status: \(keychainManager.getAuthenticationStatus())")
      print("===============================")
    }

    /// Simulate an error to test error handling
    func debugSimulateError() {
      transition(
        to: .error(
          .networkError(
            NSError(
              domain: "DebugError", code: 999, userInfo: [NSLocalizedDescriptionKey: "Test error"]))
        ))
    }

    /// Simulate a successful authentication
    func debugSimulateSuccessfulAuth() {
      Task {
        await authenticateWithAuth0()
      }
    }

    /// Force logout for tests
    func debugForceLogout() {
      Task {
        await logout()
      }
    }
  }
#endif

// MARK: - Error Recovery

extension ParapenteStateManager {

  /// Attempt to recover from an error
  func recoverFromError() async {
    switch currentState {
    case .error(let error):
      print("Attempting error recovery: \(error)")

      switch error {
      case .authenticationFailed, .tokenExpired:
        // Authentication errors -> return to authentication
        transition(to: .authentication)

      case .networkError:
        // Network errors -> check connectivity and retry
        if let networkService = networkService, networkService.isConnected {
          await checkAuthenticationState()
        } else {
          showErrorMessage("Check your internet connection and try again")
        }

      case .channelNotFound, .insufficientPermissions:
        // Channel errors -> return to selection
        await loadAvailableChannels()

      case .transmissionFailed, .audioError:
        // Transmission errors -> cleanup and return to channel
        if let pttChannelManager = pttChannelManager,
          let currentChannel = await getCurrentChannel(from: pttChannelManager)
        {
          transition(to: .channelJoined(channel: currentChannel))
        } else {
          await loadAvailableChannels()
        }

      default:
        // Other errors -> return to authentication
        transition(to: .authentication)
      }

    default:
      print("No error to recover")
    }
  }
}

// MARK: - Background Task Management

extension ParapenteStateManager {

  /// Handle entering background
  func handleAppDidEnterBackground() {
    print("Application entered background")

    // Pause transmissions if necessary
    // The PTT framework will continue to run in the background
  }

  /// Handle returning to foreground
  func handleAppWillEnterForeground() {
    print("Application returning to foreground")

    Task {
      // Check authentication state
      await checkAuthenticationState()

      // Reload data if needed
      if case .authenticated = currentState {
        await loadAvailableChannels()
      }
    }
  }

  /// Go back to previous state
  func goBack() async {
    switch currentState {
    case .error, .channelSelection:
      do {
        let permissions = try keychainManager.getUserPermissions() ?? []
        transition(to: .authenticated(permissions: permissions))
      } catch {
        transition(to: .authenticated(permissions: []))
      }
    case .channelJoined, .activeTransmission:
      await leaveChannel()
      do {
        let permissions = try keychainManager.getUserPermissions() ?? []
        transition(to: .authenticated(permissions: permissions))
      } catch {
        transition(to: .authenticated(permissions: []))
      }
    default:
      transition(to: .launching)
    }
  }

  /// Retry current operation
  func retry() async {
    switch currentState {
    case .error:
      await checkAuthenticationState()
    default:
      break
    }
  }

  /// Leave current channel
  func leaveChannel() async {
    do {
      try await pttChannelManager?.leaveCurrentChannel()
      do {
        let permissions = try keychainManager.getUserPermissions() ?? []
        transition(to: .authenticated(permissions: permissions))
      } catch {
        transition(to: .authenticated(permissions: []))
      }
    } catch {
      transition(to: .error(.networkError(error)))
    }
  }
}
